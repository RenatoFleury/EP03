#########################################################
# Exercício Programa 3 - Método dos Elementos Finitos   #
#                                                       #
# Alunos: Danilo Oliveira da Silva,    nUSP: 11848080   #
#         Renato Naves Fleury,         nUSP: 11805269   #
#########################################################

# from cmath import pi
import numpy as np
import math
from matplotlib import pyplot as plt

#########################################################
# Resolução de matriz tridiagonal por LU                #
#########################################################
def matriz_aciclica(n, a, b, c, d):
    
    n = int(n)
    l = np.zeros(n)
    u = np.zeros(n)

    # Declaração de vetores solução:
    x = np.zeros(n)
    y = np.zeros(n)

    # Determinação dos vetores l e u:
    for i in range (n):
        if (i == 0):
            u[i] = b[i]
        else:
            l[i] = a[i]/u[i-1]
            u[i] = b[i] - l[i]*c[i-1]

    # Resolução Ly = d:
    for i in range (n):
        if (i == 0):
            y[i] = d[i]
        else:
            y[i] = d[i] - l[i]*y[i-1]

    # Resolução Ux = y:
    for i in range (n):
        j = n-1-i
        if (j == n-1):
            x[j] = y[j]/u[j]
        else:
            x[j] = (y[j] - c[j]*x[j+1])/u[j]

    # Saída = vetor solução do sistemas Ax=d
    return x

#########################################################
# Integral Numérica de Gauss: f(x)dx em [a,b]           #
#########################################################
def integral_gauss_1A(f):
    W_d = [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688]
    X_d = [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640]
    X = np.array(X_d)
    W = np.array(W_d)
    X = np.concatenate((-X[::-1], X))
    W = np.concatenate((W[::-1], W))
    somatorio = 0
    for i in range(10):
        somatorio += W[i] * f(X[i])    
    return somatorio

def integral_gauss_1B(f, a, b):
    def g(u):
        return (f((b+a)/2 + (b-a)*u/2) * (b-a)/2)
    return integral_gauss_1A(g)


#########################################################
# Método de Elementos finitos                           #
#########################################################
# Determinação da base:
def base_phi(L, n, x):
    h = L/(n+1)
    x_i = np.zeros(n+2)
    for i in range (n+2):
        x_i[i] = i*h

    phi = np.zeros(n+1)
    for i in range(1,n+1):
        if ((x >= 0 and x <= x_i[i-1]) or (x > x_i[i+1] and x <= L)):
            phi[i] = 0
        elif (x > x_i[i-1] and x <= x_i[i]):
            phi[i] = (x - x_i[i-1])/h
        elif (x > x_i[i] and x <= x_i[i+1]):
            phi[i] = (x_i[i+1] - x)/h
    phi = phi[1:]
    return phi

# Determinação dos coeficientes
def coeficientes(L, n, p, q, f):
    h = L/(n+1)
    x_i = np.zeros(n+2)
    for i in range (n+2):
        x_i[i] = i*h
    
    Q1 = np.zeros(n+2)
    Q2 = np.zeros(n+2)
    Q3 = np.zeros(n+2)
    Q4 = np.zeros(n+2)
    Q5 = np.zeros(n+2)
    Q6 = np.zeros(n+2)

    def f_1(x):
        return ((x_i[i+1] - x)*(x - x_i[i])*q(x))
    def f_2(x):
        return (((x - x_i[i-1])**2)*q(x))
    def f_3(x):
        return (((x_i[i+1] - x)**2)*q(x))
    def f_4(x):
        return (p(x))
    def f_5(x):
        return ((x - x_i[i-1])*f(x))
    def f_6(x):
        return ((x_i[i+1] - x)*f(x))

    # Determinação das integrais:
    for i in range (1,n+2):
        if (i<n):
            Q1[i] = ((1/h)**2) * integral_gauss_1B(f_1, x_i[i], x_i[i+1])
            Q2[i] = ((1/h)**2) * integral_gauss_1B(f_2, x_i[i-1], x_i[i])
            Q3[i] = ((1/h)**2) * integral_gauss_1B(f_3, x_i[i], x_i[i+1])
            Q4[i] = ((1/h)**2) * integral_gauss_1B(f_4, x_i[i-1], x_i[i])
            Q5[i] = (1/h) * integral_gauss_1B(f_5, x_i[i-1], x_i[i])
            Q6[i] = (1/h) * integral_gauss_1B(f_6, x_i[i], x_i[i+1])
        elif (i==n):
            Q2[i] = ((1/h)**2) * integral_gauss_1B(f_2, x_i[i-1], x_i[i])
            Q3[i] = ((1/h)**2) * integral_gauss_1B(f_3, x_i[i], x_i[i+1])
            Q4[i] = ((1/h)**2) * integral_gauss_1B(f_4, x_i[i-1], x_i[i])
            Q5[i] = (1/h) * integral_gauss_1B(f_5, x_i[i-1], x_i[i])
            Q6[i] = (1/h) * integral_gauss_1B(f_6, x_i[i], x_i[i+1])
        elif (i==n+1):
            Q4[i] = ((1/h)**2) * integral_gauss_1B(f_4, x_i[i-1], x_i[i])
    
    a_temp = np.zeros(n+1)
    b_temp = np.zeros(n+1)
    c_temp = np.zeros(n+1)
    d_temp = np.zeros(n+1)

    # Determinação dos elementos do sistema linear Az = d
    for i in range (1,n+1):
        if (i==1):
            b_temp[i] = Q4[i] + Q4[i+1] + Q2[i] + Q3[i]
            c_temp[i] = Q1[i] - Q4[i+1]
            d_temp[i] = Q5[i] + Q6[i]
        elif (1<i<n):
            b_temp[i] = Q4[i] + Q4[i+1] + Q2[i] + Q3[i]
            c_temp[i] = Q1[i] - Q4[i+1]
            a_temp[i] = Q1[i-1] - Q4[i]
            d_temp[i] = Q5[i] + Q6[i]
        elif (i==n):
            b_temp[i] = Q4[i] + Q4[i+1] + Q2[i] + Q3[i]
            a_temp[i] = Q1[i-1] - Q4[i]
            d_temp[i] = Q5[i] + Q6[i]
    
    a = a_temp[1:]
    b = b_temp[1:]
    c = c_temp[1:]
    d = d_temp[1:]
    ci = matriz_aciclica(n, a, b, c, d)
    return ci

# Função phi:
def phi(L, n, x, p, q, f):
    base = base_phi(L, n, x)
    coeficiente = coeficientes(L, n, p, q, f)
    phi = 0
    for i in range (n):
        phi += coeficiente[i] * base[i]
    return phi


#########################################################
# Validações                                            #
#########################################################
def colors(x):
    if (x==7):
        return 'tab:orange'
    elif (x==15):
        return 'tab:red'
    elif (x==31):
        return 'tab:brown'
    elif (x==63):
        return 'tab:green'
    else:
        return 'tab:blue'
    
#########################################################
#Teste de validação do ítem 4.2 do enunciado
def validacao_1(): 
    L=1
    def p(x): # k(x)
        return 1
    def q(x):
        return 0
    def f(x):
        return (12*x*(1-x) - 2)
    def solucao(x):
        return (x**2 * (1-x)**2)
    
    valores_n = np.array([7, 15, 31, 63])
    print("\nTeste de validação 1:\n")
    print("\tParâmetros utilizados: \n\t L = 1 \n\t a = 0 \n\t b = 0 \n\t k(x) = 1 \n\t q(x) = 0 \n\t f(x) = 12x(1-x) - 2 \n")
    
    print("Diferenças máximas entre a aproximação e a solução exata analisando apenas os pontos x_i com 1<=i<=n:\n")
    for n in valores_n:
        h = L/(n+1)
        x = np.zeros(n+1)
        y1 = np.zeros(n+1)
        y2 = np.zeros(n+1)    
        dif1 = np.zeros(n+1)
        for i in range (n+1):
            x[i] = i*h
            y1[i] = solucao(x[i])
            y2[i] = phi(L,n,x[i],p,q,f)
            dif1[i] = y1[i] - y2[i]
        maximo1 = dif1.max()
        print("\tn = {} \t Diferença máxima = {:0.22f}".format(n,maximo1))
        plt.plot(x,y2,'-',c=colors(n),label=f'n = {n}',markersize=2)
    plt.grid()
    plt.legend()
    plt.title("Distribuição da temperatura em um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")    
    plt.show()
        
    print("\nDiferenças máximas entre a aproximação e a solução exata analisando 100 valores de x (igualmente espaçados) em toda a curva de aproximação para cada valor de n:\n")
    x = np.arange(2,22)
    y = np.zeros(20)
    k=0
    for n in range(2,22):
        dif2 = np.zeros(100*L + 1)
        for i in range(0,100*L + 1):
            dif2[i] = math.sqrt((solucao(i/(100))-phi(L,n,i/(100),p,q,f))**2)
        maximo2 = dif2.max()
        y[k] = maximo2
        print("\tn = {} \t Diferença máxima = {:0.22f}".format(n,maximo2))
        k+=1
    plt.plot(x,y,marker="o")
    plt.grid()
    plt.title("Erro máximo da aproximação em função de n")
    plt.xlabel("Valor de n")
    plt.ylabel("Erro máximo")
    plt.xticks(x)
    plt.show()
    main()
    
#########################################################
# Teste de validação complementar do ítem 4.2 do 
# enunciado:
def validacao_2(): 
    L=1
    def p(x): # k(x)
        return (np.e**x)
    def q(x):
        return 0
    def f(x):
        return (np.e**x + 1)
    def solucao(x):
        return ((x-1)*(np.e**(-x) - 1))
    
    valores_n = np.array([7, 15, 31, 64])
    print("\nTeste de validação 2:\n")
    print("\tParâmetros utilizados: \n\t L = 1 \n\t a = 0 \n\t b = 0 \n\t k(x) = e^x \n\t q(x) = 0 \n\t f(x) = e^x + 1 \n")
    
    print("Diferenças máximas entre a aproximação e a solução exata analisando apenas os pontos x_i com 1<=i<=n:\n")
    for n in valores_n:
        h = L/(n+1)
        x = np.zeros(n+1)
        y1 = np.zeros(n+1)
        y2 = np.zeros(n+1)    
        dif1 = np.zeros(n+1)
        for i in range (n+1):
            x[i] = i*h
            y1[i] = solucao(x[i])
            y2[i] = phi(L,n,x[i],p,q,f)
            dif1[i] = y1[i] - y2[i]
        maximo1 = dif1.max()
        print("\tn = {} \t Diferença máxima = {:0.22f}".format(n,maximo1))
        plt.plot(x,y2,'-',c=colors(n),label=f'n = {n}',markersize=2)
    plt.grid()
    plt.legend()
    plt.title("Distribuição da temperatura em um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")    
    plt.show()
        
    print("\nDiferenças máximas entre a aproximação e a solução exata analisando 100 valores de x (igualmente espaçados) em toda a curva de aproximação para cada valor de n:\n")
    x = np.arange(2,22)
    y = np.zeros(20)
    k=0
    for n in range(2,22):
        dif2 = np.zeros(100*L + 1)
        for i in range(0,100*L + 1):
            dif2[i] = math.sqrt((solucao(i/(100))-phi(L,n,i/(100),p,q,f))**2)
        maximo2 = dif2.max()
        y[k] = maximo2
        print("\tn = {} \t Diferença máxima = {:0.22f}".format(n,maximo2))
        k+=1
    plt.plot(x,y,marker="o")
    plt.grid()
    plt.title("Erro máximo da aproximação em função de n")
    plt.xlabel("Valor de n")
    plt.ylabel("Erro máximo")
    plt.xticks(x)
    plt.show()
    main()
    
#########################################################
# Simulação da situação de equilíbrio com forçantes de
# calor para o caso de resfriamento uniforme:
def forcante_calor_1():
    L=20
    n = 63
    a = 273
    b = 273
    sigma = 2.5
    Q0_menos = 2.3
    Q0_mais = 10
    def p(x): # k(x)
        return 3.6
    def q(x):
        return 0
    def f(x):
        return (Q0_mais * np.e**(-((x-(L/2))/sigma)**2) - Q0_menos)
    print("Teste de equilíbrio com forçantes de calor (Resfriamento uniforme): \n")
    print("\tParâmetros utilizados: \n\t L = {} \n\t n = {} \n\t a = {} \n\t b = {} \n\t sigma = {} \n\t Q0+ = {} \n\t Q0- = {}".format(L,n,a,b,sigma,Q0_mais,Q0_menos))
    h = L/(n+1)
    x = np.zeros(n+2)
    y = np.zeros(n+2)
    for i in range (n+1):
        x[i] = i*h
        y[i] = phi(L,n,x[i],p,q,f) + a + (b-a)*x[i]/L
        #print("\t x = {:0.6f}\t Temperatura = {:0.6f}".format(x[i],y[i]))
    x[n+1] = L
    y[n+1] = b
    plt.plot(x, y)
    plt.title("Distribuição da temperatura no eixo x de um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")
    plt.grid()
    plt.show()
    main()

#########################################################
# Simulação da situação de equilíbrio com forçantes de
# calor para o caso de resfriamento com modelagem 
# anaáloga ao aquecimento:
def forcante_calor_2():
    L=20
    n = 100
    a = 273
    b = 273
    sigma = 5
    Q0_menos = 0.4
    Q0_mais = 6
    def p(x): # k(x)
        return 3.6
    def q(x):
        return 0
    def f(x):
        return (Q0_mais*np.e**(-((x-(L/2))/sigma)**2) - Q0_menos*np.e**(-((x-(L/2))/sigma)**2))
    print("Teste de equilíbrio com forçantes de calor (Resfriamento modelado por Gaussiana): \n")
    print("\tParâmetros utilizados: \n\t L = {} \n\t n = {} \n\t a = {} \n\t b = {} \n\t sigma = {} \n\t Q0+ = {} \n\t Q0- = {}".format(L,n,a,b,sigma,Q0_mais,Q0_menos))
    h = L/(n+1)
    x = np.zeros(n+2)
    y = np.zeros(n+2)
    for i in range (n+1):
        x[i] = i*h
        y[i] = phi(L,n,x[i],p,q,f) + a + (b-a)*x[i]/L
        #print("\t x = {:0.6f}\t Temperatura = {:0.6f}".format(x[i],y[i]))
    x[n+1] = L
    y[n+1] = b
    plt.plot(x, y)
    plt.title("Distribuição da temperatura no eixo x de um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")
    plt.grid()
    plt.show()
    main()

#########################################################
# Simulação da situação de equilíbrio com forçantes de
# calor para o caso de resfriamento mais acentuado 
# mais próximo dos extremos:
def forcante_calor_3():
    L=20
    n = 100
    a = 273
    b = 273
    sigma = 10
    Q0_menos = 0.75
    Q0_mais = 0.9
    def p(x): # k(x)
        return 3.6
    def q(x):
        return 0
    def f(x):
        return (Q0_mais*np.e**(-((x-(L/2))/sigma)**2) - Q0_menos*(np.e**(-(x/sigma)**2) + np.e**(-((x-L)/sigma)**2)))
    print("Teste de equilíbrio com forçantes de calor (Resfriamento acentuado nas extremidades): \n")
    print("\tParâmetros utilizados: \n\t L = {} \n\t n = {} \n\t a = {} \n\t b = {} \n\t sigma = {} \n\t Q0+ = {} \n\t Q0- = {}".format(L,n,a,b,sigma,Q0_mais,Q0_menos))
    h = L/(n+1)
    x = np.zeros(n+2)
    y = np.zeros(n+2)
    for i in range (n+1):
        x[i] = i*h
        y[i] = phi(L,n,x[i],p,q,f) + a + (b-a)*x[i]/L
        #print("\t x = {:0.6f}\t Temperatura = {:0.6f}".format(x[i],y[i]))
    x[n+1] = L
    y[n+1] = b
    plt.plot(x, y)
    plt.title("Distribuição da temperatura no eixo x de um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")
    plt.grid()
    plt.show()
    main()

#########################################################
# Simulaçao da situação com variação do material na qual
# o material que envolve o chip é o alumínio:
def variacao_material():
    L=20
    n = 100
    a = 273
    b = 273
    d = L/5
    sigma = 2
    Q0_menos = 0.5
    Q0_mais = 5
    def p(x): # k(x)
        if (x>(L/2 - d) and x<(L/2 + d)):
            return 3.6
        else:
            return 60
    def q(x):
        return 0
    def f(x):
        return (Q0_mais * np.e**(-((x-(L/2))/sigma)**2) - Q0_menos)
    print("Teste de equilíbrio com variação do material: \n")
    print("\tParâmetros utilizados: \n\t L = {} \n\t n = {} \n\t a = {} \n\t b = {} \n\t d = {} \n\t sigma = {} \n\t Q0+ = {} \n\t Q0- = {}".format(L,n,a,b,d,sigma,Q0_mais,Q0_menos))
    h = L/(n+1)
    x = np.zeros(n+2)
    y = np.zeros(n+2)
    for i in range (n+1):
        x[i] = i*h
        y[i] = phi(L,n,x[i],p,q,f) + a + (b-a)*x[i]/L
        #print("\t x = {:0.6f}\t Temperatura = {:0.6f}".format(x[i],y[i]))
    x[n+1] = L
    y[n+1] = b
    plt.plot(x, y)
    plt.title("Distribuição da temperatura no eixo x de um chip de silício")
    plt.xlabel("Posição [mm]")
    plt.ylabel("Temperatura [K]")
    plt.grid()
    plt.show()
    main()

    
def main():
    print("\nSimulções exploradas:\n")
    print("\t1 - Teste de validação do ítem 4.2 do enunciado.")
    print("\t2 - Teste de validação complementar do ítem 4.2 do enunciado.")
    print("\t3 - Simulação da situação de equilíbrio com forçantes de calor com resfriamento uniforme.")
    print("\t4 - Simulação da situação de equilíbrio com forçantes de calor com resfriamento com modelagem análoga ao aquecimento.")
    print("\t5 - Simulação da situação de equilíbrio com forçantes de calor com resfriamento acentuado nas extremidades.")
    print("\t6 - Simulação da situação de equilíbrio com variação de material.")
    a = int(input("\nDigite o número do teste a ser simulado: "))
    if (a == 1):
        validacao_1()
    elif (a == 2):
        validacao_2()
    elif (a == 3):
        forcante_calor_1()
    elif (a == 4):
        forcante_calor_2()
    elif (a == 5):
        forcante_calor_3()
    elif (a == 6):
        variacao_material()
    else:
        print("Por favor, insira um numero valido")
        main()
main()
          
